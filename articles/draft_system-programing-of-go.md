---
title: "「Goならわかるシステムプログラミング」要点"
emoji: "🌟"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Go"]
published: false
---

# 書籍

https://www.lambdanote.com/collections/go-2/products/go-2

# 参考

コードを動かすために作ったレポジトリ。
https://github.com/ito0804takuya/go-sytem-programing

以前 Go を学習した際の自分の記事も参照。

# 第 1 章 Go 言語で覗くシステムプログラミングの世界

## 1.1 システムプログラミングとは

**システムプログラミングとは、OS の提供する機能を使ったプログラミング**。
（Web 関係のプログラミングとは対照的な場面で使われる言葉。）

### OS の機能

ボトムアップではレベルアップにつながる実感が湧きづらい OS の機能（下記）を、
プログラマー目線で、普段の開発にもフィードバックできるように見ていく。

- メモリの管理
- プロセスの管理
- プロセス間通信
- ファイルシステム
- ネットワーク
- ユーザー管理（権限など）
- タイマー

## 1.2 Go 言語

多くの OS の機能を直接扱える。
少ない行数で動くアプリケーションが作れる。

現在のシステムプログラミングでは主に C, C++が使われている。

- C, C++と比較したメリット
  - ライブラリの収集が簡単。
  - コンパイルで多くのエラーが見つかる。
  - 実行時のエラーがわかりやすい。
  - メモリ管理を注意深く設計しなくて済む。（ガベージコレクション）
  - コンパイルが速い。
- デメリット
  - （スクリプト言語よりは速いが）、C, C++と比較すると遅い。
  - バイナルサイズがかなり大きくなる。

:::details go mod init の解説

#### プロジェクト作成後の初期化

`mod init`を実行すると、go.mod ファイルが生成され、Go の処理系から、このファイルがある場所がこのプロジェクトのルートと認識される。

```bash
go mod init <プロジェクト名>
```

:::

## 1.4 デバッガーを使って "Hello World!"の裏側を覗く

`fmt.Println("Hello", "World!")`について、裏側でどういう処理が行われているか、関数の定義をたどっていくことで確認していく。
→ **最終的には、システムコールを呼び出している**ことが分かった。

#### システムコールとは（ざっくり）

- アプリケーションのプログラム単体では達成できない仕事を、OS のカーネルに依頼するために使う。
  （`syscall.Write()`では、（プログラムの外の世界である）ターミナルに対して文字列を出力するという仕事 を依頼している。）
- いくつも種類がある。

:::details 可変長引数関数

#### 可変長引数関数(Variadic function) `...`

メソッドの引数が、同じ型の複数個の場合、`...`(ドット 3 つ)で示す。

```go
func method(args ...Type)
```

- 参考記事 : https://zenn.dev/mikankitten/articles/cfa2ef834e338e

:::

:::details interface{}型

#### interface{}型

interface{}型は int, string, bool などと同じ、golang の型名。{}の部分まで含めて型名。
どんな型も格納できる特殊な型。

- 参考記事 : https://qiita.com/sh-tatsuno/items/0c32c01eaeaf2d726fdf

:::

# 第 2 章 低レベルアクセスへの入口 1：io.Writer

## 2.1 io.Writer は OS が持つファイルのシステムコールの相似形

OS は、システムコール（例えば 1 章の`syscall.Write()`）を呼び出すとき、ファイルディスクリプタ（`1`, `2`などの識別子）を指定する。
そうすることで、ファイルディスクリプタで指定したモノにアクセスできる。

ファイルディスクリプタに対応するモノには、ファイルのみならず、標準入出力・ソケットなどのファイルでないものも含まれ、ファイルと同じようにアクセスできる。
→ **ファイルディスクリプタは、色々なモノをファイルとしてアクセスできるように抽象化している**。

## 2.2 Go 言語のインタフェース

- `動名詞(その振る舞いの動詞 + er)`で命名することが多い。

## 2.3 io.Writer は「インタフェース」

OS のレイヤー（Go より下）では、ファイルディスクリプタを使って、色々なモノをファイルとして抽象化しているが、
Go のレイヤーでは、io.Writer インターフェースが抽象化して表現している。

```go
// os.File型
func (f *File) Write(b byte[]) (n int, err error) { ... }

// io.Writerインターフェース
type Writer interface {
	Write(b byte[]) (n int, err error)
}
```

:::message
インターフェースは、"どんなことができるか"を表現している。
（例: io.Writer は、何かを何かに書き込みするもの。）
:::

## 2.4 io.Writer を使う構造体の例

下記の構造体は io.Writer インターフェースを実装している。（`Write()`メソッドを持っている。）

- os.File : ファイルへ書き込み。
- os.Stdout, os.Stderr
- bytes.Buffer : バッファに書き込んで記録しておいて、後でまとめて取得。
- strings.Builder : bytes.Buffer の string 専用 ver.。
- net.Conn : 通信のコネクション。
- http.ResponseWriter : HTTP レスポンス。
  などなど

下記は、io.Writer に書き出す例。

- `fmt.Fprintf(io.Writer, 出力したい文字列, 文字列にてフォーマット出力するデータ)`

## 2.5 インタフェースの実装状況・利用状況を調べる

"_私（構造体）はこのインターフェースを実装しています_"ということは、構造体には記述しない。
とあるインターフェースを実装しているのか知りたい場合は、VSCode の場合は、そのインターフェースを指定して"右クリック → 実装へ移動"。

## 2.7 柔軟性が高く、パフォーマンスのよい設計のための Tips.

- データの入出力・加工を行う関数を書く場合、ファイル名やバイト列でなく、io.Reader や io.Writer を受け取るようにすると良い。

# 第 3 章 低レベルアクセスへの入口 2：io.Reader

## 3.1 io.Reader

- `Read(p [byte])`の`p`はバッファ（メモリ）であり、
  `buffer := make([]byte, 1024)`などとして先に確保しておく必要がある。（ちょっと面倒くさい）

## 3.2 io.Reader の補助関数

- `io.Copy(dst io.Writer, src io.Reader)`で、Reader から Writer にデータをそのまま渡せる。

## 3.3 入出力に関する io.Writer と io.Reader 以外のインタフェース

- io.Closer : 使用し終わったファイルを閉じる`Close()`を持つ。
- io.Seeker : 読み込み位置を移動する`Seek()`を持つ。
- io.ReaderAt : `ReadAt()`を持つ。（あまり使わないようなので理解を飛ばした。）

## 3.4 io.Reader を満たす構造体で、よく使うもの

- os.Stdin : 標準入力。`os.Stdin.Read(buffer)`
- os.File : ファイル内容を入力とする。`os.Open(ファイル)`
- net.Conn
- bytes.Buffer

<!-- ## 3.5 バイナリ解析用の io.Reader 関連機能 -->

## 3.6 テキスト解析用の io.Reader 関連機能

- 文字列を読み込む
  - bufio.NewScanner() : デフォは改行で区切る。`scanner.Split(bufio.ScanWords)`で単語で区切る。
- 文字列や数値などを読み込む
  - fmt.Fscan() : 半角スペース区切り
  - fmt.Fscanln() : 改行区切り
  - fmt.Fscanf() : 何で区切るかを指定する
- csv
  - encoding/csv パッケージ
- json
  - encoding/json パッケージ

## 3.7 io.Reader／io.Writer でストリームを自由に操る

- io.MultiReader : 複数の Reader をまとめて 1 つの Reader として扱う。
- io.TeeReader : `teeReader := io.TeeReader(reader, writer)`で、"reader" から "writer と teeReader の両方"にデータを流し込む。
- io.Pipe : Writer に書き込むと Reader から出力される。

<!-- TODO 章末問題ができていないので、やること！ -->

# 第 4 章 低レベルアクセスへの入口 3：チャネル

## 4.1 goroutine.

`go`をつけて実行すれば並行処理ができる。

## 4.2 チャネル

- チャネルは、キュー ＋ 並列でアクセスされても正しく処理されることを保証する機能 を組み合わせたもの。

  - チャネルは、データを順序よく受け渡すためのデータ構造。
    キュー（**FIFO**）。指定した位置のデータへのアクセスはできなく、投入と取り出しだけができる。
  - チャネルは、並列処理されても正しくデータを受け渡す**同期機構**。
    同時に複数の goroutine がチャネルに読み書きをしても、1 つの goroutine だけがデータの投入や取り出しができる。
  - チャネルは、**読み込み・書き込みで準備ができるまでブロック**する。
    - データがない状態で読み込みをした場合：他の goroutine が書き込みをするまでブロックして待つ。
    - バッファに空きがない状態で書き込みをした場合：他の goroutine がデータを取り出して空きができるまでブロックして待つ。

- 送受信のやり方

  - 送信
    - `チャネル<-値` : バッファありチャネルの場合、バッファに格納。バッファなしチャネルの場合、受信されるまで停止（ブロック）。close したチャネルの場合、パニック。
  - 受信
    - `変数 := <-チャネル` : 受信して変数へ格納。
    - `変数, ok := <-チャネル` : close したチャネルの場合は、ok は false になる。
    - `<-チャネル` : 受信するが、受信した値は捨てる。
    - `for 変数 := range チャネル` : 受信するたびに for ループが実行される。

- select : 複数のチャネルがある場合に、先に受信した方のチャネルのデータを使うときに`select`を使う。

- コンテキスト : ネストされたゴルーチンや、派生ジョブがある複雑なロジックなどにおいても、正しく処理の**キャンセル**や終了・タイムアウトができる。context パッケージ。

<!-- TODO 章末問題ができていないので、やること！ -->

# 第 5 章 システムコール

## 5.1 システムコールとは何か？

- システムコールとは、「特権モードで OS の機能を呼ぶこと」。

  - **特権モード**とは、**ユーザーモード**よりも強い権限を持って CPU の機能を使えるモード。
  - システムコールが無いと、プロセス間通信・ファイルの入出力・共有メモリへの書き出し・外部 Web サービスなどとの通信 などができない。
    （共有メモリとか、ここに出てきた単語の意味はよく分かってない。）

## 5.3 POSIX と C 言語の標準規格

- POSIX は、システムコールのインターフェースを取り決めた規格。OS の移植性を高めるため。

<!-- TODO 章末問題ができていないので、やること！ -->

# 第 6 章 TCP ソケットと HTTP の実装

## 6.1 プロトコルとレイヤー

- TCP/IP 参照モデル
  - アプリケーション層 : HTTP
  - トランスポート層 : TCP, UDP
  - インターネット層 : IP
  - リンク（物理）層 : WiFi, イーサネット

## 6.2 HTTP とその上のプロトコルたち

HTTP は、TCP や UDP を利用して通信する、定型のフォーマット。
そのフォーマットどおりに記載されたデータを、HTTP リクエスト/レスポンスとしてやり取りする。

## 6.3 ソケットとは

- アプリケーション層（HTTP）からトランスポート層（TCP, UDP）を利用するときの API として、ソケットを利用している。

  - TLS（SSL）は HTTP とソケットの間に入って暗号化している。

- ソケットには以下の種類などがある。
  - TCP ソケット : 安定性が高い。互いに挨拶してから会話を始める。
  - UDP ソケット : 通信開始が早い。相手に一方的にデータを送りつける。
  - Unix ドメインソケット : ローカル通信でしか使えないが、最速。

## 6.4 ソケット通信の基本構造

- どんな種類のソケット通信も、下記のような形態。
  - サーバー : ソケットを開いて待ち受ける。
    - Go では、`Listen()`
  - クライアント : 開いているソケットに接続し、通信する。
    - Go では、`Dial()`

## 6.5 Go 言語で HTTP サーバーを実装する

https://github.com/ito0804takuya/go-sytem-programing/commit/0d829eec1635b5c7e1fa6f02746647c36eaf6ef6

## 6.6 速度改善（1）: HTTP/1.1 の Keep-Alive に対応させる

HTTP/1.0 では 1 セットの通信が終わるたびに TCP のコネクションを切断するが、
HTTP/1.1 では`Keep-Alive`を使うことでしばらくは TCP のコネクションを維持して使い回す。

## 6.7 速度改善（2）:圧縮

クライアントは`Accept-Encoding`で、自身が読み込める形式を指定。（gzip など）
レスポンスの`Content-Encoding`で、サーバーがどういうデータ（どう圧縮したのか）を返してきたか確認する。

## 6.8 速度改善（3）:チャンク形式のボディー送信

大きいデータを一度に返すのでなく、細切れにして少しずつ送るには、`Transfer-Encoding: chunked`とヘッダーに付ける。

# 第 7 章 UDP ソケットを使ったマルチキャスト通信

## 7.1 UDP と TCP の用途の違い

- 信頼性は低い。
- UDP はコネクションを繋がず、相手のポートにデータを送りつけるので、TCP で接続時に行う 3way ハンドシェイクを UDP では行わない。（時間がかからない。）
- マルチキャスト、ブロードキャストができる。

## 7.2 UDP と TCP の処理の流れの違い

https://github.com/ito0804takuya/go-sytem-programing/commit/1beae5b818ce98b1483abf490193f310b05d7ad6

- コネクションを繋がないのだが、Go 言語で UDP を実装する際には`net.Conn` や `net.PacketConn` 構造体を使って、TCP と同じ感覚で Conn に対して Read や Write を行う。（Go 特有）

# 第 8 章 高速な Unix ドメインソケット

## 8.1 Unix ドメインソケットの基本

- Unix ドメインソケットは、TCP 型（ストリーム型）と UDP 型（データグラム型）の両方の使い方がある。
- 通信相手を、（通常のソケット通信のように IP アドレス+ポート番号で探すのでなく）ファイルパスを使って探す。
  ただし、実体のある普通のファイルではなく、ソケットファイルという特殊なファイル。ファイルに読み書きするのではなく、あくまでプロセス間の高速な通信を実現するために、ファイルというインターフェースを利用するだけ。

# 第 9 章 ファイルシステムの基礎と Go 言語の標準パッケージ

## 9.1 ファイルシステムの基礎

- ファイルシステムはストレージ上に 1 つしかないわけでなく、Docker で使われている、chroot による擬似的なファイルシステムなども含め、複数存在する。
  これらの様々なファイルシステムは、VFS（Virtual File System）という API で、統一的に扱えるようになっている。

- ボリュームについて、論理ボリュームマネージャ（LVM）により、複数の**ストレージ（物理）**を束ねて、論理ボリュームグループを作って大きな仮想ストレージを作る。それを**ボリューム（論理）**に分割して、VFS にマウントする。

## 9.2 ファイル／ディレクトリを扱う Go 言語の関数たち

- `File.Sync()`で確実にストレージに書き込まれたことを確認できる。（Write ではメモリに書き込んだだけなので。）
  だが、重たい処理。

## 9.4 ファイルパスとマルチプラットフォーム

- `path/filepath` : OS のファイルシステムに使う
- `path` : URL に使う

## 9.5 path/filepath パッケージの関数たち

これらのパッケージを使って、簡単にファイルシステムの操作ができる。
https://pkg.go.dev/path/filepath
https://pkg.go.dev/os

# 第 10 章 ファイルシステムの最深部を扱う Go 言語の関数

## 10.1 ファイルの変更監視（syscall.Inotify\*）

ファイルの変更を監視する（例：ソースコードの変更を検知して自動コンパイル）には、2 種類の方法がある。

- 監視したいファイルを OS に通知して、変更があったら教えてもらう。（OS に任せる、パッシブな方式）
- タイマーなどで定期的にフォルダを走査して、`os.Stat()`などを使って変更を探しに行く。（自ら探す、アクティブな方式）

## 10.2 ファイルのロック（syscall.Flock()）

ファイルロックのためのシステムコール`syscall.Flock()`で、ロック中のファイルに他のプロセスがロックをかけようとするとブロックする。

## 10.3 ファイルのメモリへのマッピング（syscall.Mmap()）

システムコール`syscall.Mmap()`をラップしたパッケージがいくつかある。Go 言語の実験的パッケージ（discover package）の[mmap](https://pkg.go.dev/golang.org/x/exp/mmap)や、[mmap-go](https://github.com/edsrzf/mmap-go)。

ファイルの中身をそのままメモリ上に展開して、メモリ上で書き換えた内容をファイルに書き込むことができる。（つまり、ファイルをメモリを同期（mapping）させる。）

## 10.4 同期・非同期／ブロッキング・ノンブロッキング

ファイル I/O やネットワーク I/O などは、CPU 内部の処理に比べると非常に遅い。
重い処理に引きづられてプログラム全体が遅くならないようにする仕組みの分類として、同期/非同期処理、ブロッキング/ノンブロッキング処理という種類がある。

Go は同期・ブロッキング処理（シンプルだがパフォーマンスは良くない）だが、ゴルーチンをたくさん実行すると非同期・ノンブロッキング（高速）になる。

### 同期/非同期処理

実データを取りに行くのか、通知をもらうかの違い。

- 同期処理　：OS に I/O タスクを投げて、入出力の準備ができたらアプリケーションに処理が返ってくる。
- 非同期処理：OS に I/O タスクを投げて、入出力の準備ができたら**通知をもらう**。

### ブロッキング/ノンブロッキング処理

依頼したタスクの**結果の受け取り方**の違い。

- ブロッキング処理　　：依頼した I/O タスクの結果の準備ができるまで待つ。（自分は停止）
- ノンブロッキング処理：依頼した I/O タスクの結果の準備ができるのを待たない。（自分は停止しない）

## 10.6 FUSE を使った自作のファイルシステムの作成

ファイルシステムはカーネルで実行されるため、新しくファイルシステムを構成しようとすると本来はファイルシステムの開発や変更が必要だが、
**FUSE**（**Filesystem in Userspace**）というインターフェースを使って手軽に（カーネルでなく）ユーザ空間で動作するファイルシステムを構成できる。
それを使って、AWS などのクラウドストレージをマウントして、ローカルフォルダにあるかのように見せるファイルシステムが作れる。
クラウドへのアクセスは、gocloud.dev で提供されているパッケージを使う。

# 第 11 章 コマンドシェル

## 11.1 シェルとは何か

シェルとは、ユーザがコンピュータを使うときの接点。
bash, zsh とかはコマンドシェル。

## 11.2 シェルの利用形態

Terminal や iTerm2 などは、端末エミュレータ。

外部コマンド（`ls`など）を実行する方法は、シェル経由のコマンド実行と、親プロセスから子プロセスを直接起動するという 2 つの方式がある。
Go の`os/exec`は後者しかサポートしていないが、下記のようにすれば 2 通りとも実行できる。

```go:直接起動
// exec.Commandでコマンドを指定
cmd := exec.Command("ls", "-l")

// コマンドの出力を取得
output, err := cmd.Output()
if err != nil {
    log.Fatal(err)
}

// 出力を文字列として表示
fmt.Printf("Command output:\n%s\n", output)
```

```go:シェル経由
// シェル経由でコマンドを指定
cmd := exec.Command("sh", "-c", "ls -l")

// 以降は同上
```

## 11.3 POSIX、SUS、LSB、BusyBox

POSIX（= SUS）は、OS の標準規格。搭載すべき CLI コマンドなどを定義している。これに準拠していると UNIX を名乗れる。
LSB（Linux Standard Base）は、SUS の定義するサブセットに、GUI まわりのパッケージを追加した規格。
POSIX や LSB が巨大な規格なため、それらの小さいサブセットとして BusyBox がある。軽量な Alpine は BusyBox をコアとして使っている。

## 11.4 環境変数

https://github.com/ito0804takuya/go-sytem-programing/commit/68b8030c5f29696a94f3fb314d44635c666f388b

# 第 12 章 プロセスの役割と Go 言語による操作

## 12.1 プロセスに含まれるもの（Go 言語視点）

プロセスとは、簡単に言うと「実行中のプログラム」。
ちゃんと言うと「実行ファイル（プログラム）を実行するために必要なリソース（メモリや CPU など）も含めたプログラムの実行単位」。

### プロセスに含まれるもの

- 実行ファイルパス
  やりたいことが書かれたプログラムがどこにあるか。
- プロセス ID
  プロセスごとにユニークな ID。`os.Getpid()`
- プロセスグループ ID、セッショングループ ID
  - プロセスグループ
    プロセスを束ねたグループのこと。別名 ジョブ。
    `cat sample.txt | echo`というコマンドの場合、`cat`と`echo`は別プロセスで、これらを`|`で繋いで実行される一式がプロセスグループ。
  - セッショングループ（セッション）
    同じターミナルで起動したアプリケーションは同じセッショングループになる。そういう感じ。（あまり重要じゃないと思ったのでこんなところで済ませた。）
- ユーザー ID、グループ ID
  子プロセスは親プロセスのユーザー ID、グループ ID を引き継ぐ。
  - ユーザー
    プロセスを実行しているユーザー権限。
  - グループ（ユーザーのグループ）
    ユーザーが所属しているグループ。ユーザーが所属できるメインのグループは 1 つのみで、サブのグループには複数入れる。
- 実効ユーザー ID、実効グループ ID
  SUID(Set UserID)や SGID フラグを付与した場合、所有者が実行したことになる。その場合のユーザー ID、グループ ID のこと。
- 作業ディレクトリ
- ファイルディスクリプタ
  使用するファイルやソケット、標準入力/標準出力/標準エラー出力などのリソースは、全てファイルとして扱える。それらのファイルディスクリプタ（識別子）をプロセスは保持している。

## 12.2 プロセスの入出力

- 終了コード
  正常終了は 0、失敗があった場合は 1 以上。
  多くの言語はこれ以上の意味を終了コードに持たせていないが、bash は数字によって意味を定義していたりする。

## 12.3 自分以外のプロセスの名前や資源情報の取得

pid から、そのプロセスが何者かを知るには、`gopsutil`を使うといい。

## 12.4 OS から見たプロセス

OS から見ると、プロセスはタスク。OS の仕事は、たくさんのプロセスに、効率よくタスクをさせること。

## 12.5 Go プログラムからのプロセスの起動

Go でコマンド（プロセス）を起動するには、以下の 2 種類の方法がある。

- `os.Process`
  低レベルな構造体。
- `exec.Cmd`
  少し高機能な構造体。内部で`os.Process`を持つ。

Run()で実行。ProcessState で状態を把握できる。StdoutPipe()などで入出力のパイプ渡し。Kill()で終了。という感じで使う。

## 12.6 プロセスに関する便利な Go 言語のライブラリ

- 出力する文字に色を付けたいとき、ANSI エスケープシーケンスを使う。
  OS ごとの互換性がないので、`go-colorableのNewColorableStdout()`を使ってその環境差を吸収する。
  また、その出力が擬似端末（おそらくターミナルのこと）に繋がっているのか、判断が必要。
  それは `go-isattyのIsTerminal()` で行うことができる。

<!-- 一旦中断。Go（と設計とAWS）の勉強に時間を集中させる -->

12.7 Go 言語では触れることのない世界
　 12.8 子プロセスの内部実装
　 12.9 本章のまとめと次章予告

第 13 章 シグナルによるプロセス間の通信
　 13.1 シグナルのライフサイクル
　 13.2 シグナルの種類
　 13.3 Go 言語におけるシグナルの種類
　 13.4 シグナルのハンドラを書く
　 13.5 シグナルの応用例（Server::Starter）
　 13.6 Go 言語ランタイムにおけるシグナルの内部実装
　 13.7 Windows とシグナル
　 13.8 本章のまとめと次章予告

第 14 章 Go 言語と並列処理
　 14.1 複数の仕事を同時に行うとは？
　 14.2 Go 言語の並列処理のための道具
　 14.3 スレッドと goroutine の違い
　 14.4 Go のランタイムはミニ OS
　 14.5 runtime パッケージの goroutine 関連の機能
　 14.6 RaceDetector
　 14.7 sync パッケージ
　 14.8 sync/atomic パッケージ
　 14.9 本章のまとめと次章予告

第 15 章 並行・並列処理の手法と設計のパターン
　 15.1 並行・並列処理の手法のパターン
　 15.2 Go における並行・並列処理のパターン集
　 15.3 本章のまとめと次章予告

第 16 章 Go 言語のメモリ管理
　 16.1 メモリ確保の旅
　 16.2 Go 言語の配列
　 16.3 スライスなど
　 16.4 ガベージコレクタ
　 16.5 本章のまとめと次章予告

第 17 章 実行ファイルが起動するまで
　 17.1 実行ファイルが起動するまで
　 17.2 実行ファイルを支える仕組み
　 17.3 実行ファイルのメモリ配置
　 17.4 Go のプログラムの起動
　 17.5 インタプリタでのコードの起動
　 17.6 まとめ

第 18 章 時間と時刻
　 18.1 OS のタイマー／カウンターの仕組み
　 18.2 さまざまな時間
　 18.3 時間に関するシステムコール
　 18.4 Go 言語で時間を扱う
　 18.5 時刻のフォーマット
　 18.6 本章のまとめと次章予告

第 19 章 Go 言語とコンテナ
　 19.1 仮想化
　 19.2 コンテナ
　 19.3 Windows Subsystem for Linux 2（WSL2）
　 19.4 libcontainer でコンテナを自作する
　 19.5 本章のまとめ
