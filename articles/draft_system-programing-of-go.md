---
title: "「Goならわかるシステムプログラミング」要点"
emoji: "🌟"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Go"]
published: false
---

# 書籍

https://www.lambdanote.com/collections/go-2/products/go-2

# 参考

コードを動かすために作ったレポジトリ。
https://github.com/ito0804takuya/go-sytem-programing

以前 Go を学習した際の自分の記事も参照。

# 第 1 章 Go 言語で覗くシステムプログラミングの世界

## 1.1 システムプログラミングとは

**システムプログラミングとは、OS の提供する機能を使ったプログラミング**。
（Web 関係のプログラミングとは対照的な場面で使われる言葉。）

### OS の機能

ボトムアップではレベルアップにつながる実感が湧きづらい OS の機能（下記）を、
プログラマー目線で、普段の開発にもフィードバックできるように見ていく。

- メモリの管理
- プロセスの管理
- プロセス間通信
- ファイルシステム
- ネットワーク
- ユーザー管理（権限など）
- タイマー

## 1.2 Go 言語

多くの OS の機能を直接扱える。
少ない行数で動くアプリケーションが作れる。

現在のシステムプログラミングでは主に C, C++が使われている。

- C, C++と比較したメリット
  - ライブラリの収集が簡単。
  - コンパイルで多くのエラーが見つかる。
  - 実行時のエラーがわかりやすい。
  - メモリ管理を注意深く設計しなくて済む。（ガベージコレクション）
  - コンパイルが速い。
- デメリット
  - （スクリプト言語よりは速いが）、C, C++と比較すると遅い。
  - バイナルサイズがかなり大きくなる。

:::details go mod init の解説

#### プロジェクト作成後の初期化

`mod init`を実行すると、go.mod ファイルが生成され、Go の処理系から、このファイルがある場所がこのプロジェクトのルートと認識される。

```bash
go mod init <プロジェクト名>
```

:::

## 1.4 デバッガーを使って "Hello World!"の裏側を覗く

`fmt.Println("Hello", "World!")`について、裏側でどういう処理が行われているか、関数の定義をたどっていくことで確認していく。
→ **最終的には、システムコールを呼び出している**ことが分かった。

#### システムコールとは（ざっくり）

- アプリケーションのプログラム単体では達成できない仕事を、OS のカーネルに依頼するために使う。
  （`syscall.Write()`では、（プログラムの外の世界である）ターミナルに対して文字列を出力するという仕事 を依頼している。）
- いくつも種類がある。

:::details 可変長引数関数

#### 可変長引数関数(Variadic function) `...`

メソッドの引数が、同じ型の複数個の場合、`...`(ドット 3 つ)で示す。

```go
func method(args ...Type)
```

- 参考記事 : https://zenn.dev/mikankitten/articles/cfa2ef834e338e

:::

:::details interface{}型

#### interface{}型

interface{}型は int, string, bool などと同じ、golang の型名。{}の部分まで含めて型名。
どんな型も格納できる特殊な型。

- 参考記事 : https://qiita.com/sh-tatsuno/items/0c32c01eaeaf2d726fdf

:::

# 第 2 章 低レベルアクセスへの入口 1：io.Writer

## 2.1 io.Writer は OS が持つファイルのシステムコールの相似形

OS は、システムコール（例えば 1 章の`syscall.Write()`）を呼び出すとき、ファイルディスクリプタ（`1`, `2`などの識別子）を指定する。
そうすることで、ファイルディスクリプタで指定したモノにアクセスできる。

ファイルディスクリプタに対応するモノには、ファイルのみならず、標準入出力・ソケットなどのファイルでないものも含まれ、ファイルと同じようにアクセスできる。
→ **ファイルディスクリプタは、色々なモノをファイルとしてアクセスできるように抽象化している**。

## 2.2 Go 言語のインタフェース

- `動名詞(その振る舞いの動詞 + er)`で命名することが多い。

## 2.3 io.Writer は「インタフェース」

OS のレイヤー（Go より下）では、ファイルディスクリプタを使って、色々なモノをファイルとして抽象化しているが、
Go のレイヤーでは、io.Writer インターフェースが抽象化して表現している。

```go
// os.File型
func (f *File) Write(b byte[]) (n int, err error) { ... }

// io.Writerインターフェース
type Writer interface {
	Write(b byte[]) (n int, err error)
}
```

:::message
インターフェースは、"どんなことができるか"を表現している。
（例: io.Writer は、何かを何かに書き込みするもの。）
:::

## 2.4 io.Writer を使う構造体の例

下記の構造体は io.Writer インターフェースを実装している。（`Write()`メソッドを持っている。）

- os.File : ファイルへ書き込み。
- os.Stdout, os.Stderr
- bytes.Buffer : バッファに書き込んで記録しておいて、後でまとめて取得。
- strings.Builder : bytes.Buffer の string 専用 ver.。
- net.Conn : 通信のコネクション。
- http.ResponseWriter : HTTP レスポンス。
  などなど

下記は、io.Writer に書き出す例。

- `fmt.Fprintf(io.Writer, 出力したい文字列, 文字列にてフォーマット出力するデータ)`

## 2.5 インタフェースの実装状況・利用状況を調べる

"_私（構造体）はこのインターフェースを実装しています_"ということは、構造体には記述しない。
とあるインターフェースを実装しているのか知りたい場合は、VSCode の場合は、そのインターフェースを指定して"右クリック → 実装へ移動"。

## 2.7 柔軟性が高く、パフォーマンスのよい設計のための Tips.

- データの入出力・加工を行う関数を書く場合、ファイル名やバイト列でなく、io.Reader や io.Writer を受け取るようにすると良い。

# 第 3 章 低レベルアクセスへの入口 2：io.Reader

## 3.1 io.Reader

- `Read(p [byte])`の`p`はバッファ（メモリ）であり、
  `buffer := make([]byte, 1024)`などとして先に確保しておく必要がある。（ちょっと面倒くさい）

## 3.2 io.Reader の補助関数

- `io.Copy(dst io.Writer, src io.Reader)`で、Reader から Writer にデータをそのまま渡せる。

## 3.3 入出力に関する io.Writer と io.Reader 以外のインタフェース

- io.Closer : 使用し終わったファイルを閉じる`Close()`を持つ。
- io.Seeker : 読み込み位置を移動する`Seek()`を持つ。
- io.ReaderAt : `ReadAt()`を持つ。（あまり使わないようなので理解を飛ばした。）

## 3.4 io.Reader を満たす構造体で、よく使うもの

- os.Stdin : 標準入力。`os.Stdin.Read(buffer)`
- os.File : ファイル内容を入力とする。`os.Open(ファイル)`
- net.Conn
- bytes.Buffer

<!-- ## 3.5 バイナリ解析用の io.Reader 関連機能 -->

## 3.6 テキスト解析用の io.Reader 関連機能

- 文字列を読み込む
  - bufio.NewScanner() : デフォは改行で区切る。`scanner.Split(bufio.ScanWords)`で単語で区切る。
- 文字列や数値などを読み込む
  - fmt.Fscan() : 半角スペース区切り
  - fmt.Fscanln() : 改行区切り
  - fmt.Fscanf() : 何で区切るかを指定する
- csv
  - encoding/csv パッケージ
- json
  - encoding/json パッケージ

## 3.7 io.Reader／io.Writer でストリームを自由に操る

- io.MultiReader : 複数の Reader をまとめて 1 つの Reader として扱う。
- io.TeeReader : `teeReader := io.TeeReader(reader, writer)`で、"reader" から "writer と teeReader の両方"にデータを流し込む。
- io.Pipe : Writer に書き込むと Reader から出力される。

<!-- TODO 章末問題ができていないので、やること！ -->

# 第 4 章 低レベルアクセスへの入口 3：チャネル

## 4.1 goroutine.

`go`をつけて実行すれば並行処理ができる。

## 4.2 チャネル

- チャネルは、キュー ＋ 並列でアクセスされても正しく処理されることを保証する機能 を組み合わせたもの。

  - チャネルは、データを順序よく受け渡すためのデータ構造。
    キュー（**FIFO**）。指定した位置のデータへのアクセスはできなく、投入と取り出しだけができる。
  - チャネルは、並列処理されても正しくデータを受け渡す**同期機構**。
    同時に複数の goroutine がチャネルに読み書きをしても、1 つの goroutine だけがデータの投入や取り出しができる。
  - チャネルは、**読み込み・書き込みで準備ができるまでブロック**する。
    - データがない状態で読み込みをした場合：他の goroutine が書き込みをするまでブロックして待つ。
    - バッファに空きがない状態で書き込みをした場合：他の goroutine がデータを取り出して空きができるまでブロックして待つ。

- 送受信のやり方

  - 送信
    - `チャネル<-値` : バッファありチャネルの場合、バッファに格納。バッファなしチャネルの場合、受信されるまで停止（ブロック）。close したチャネルの場合、パニック。
  - 受信
    - `変数 := <-チャネル` : 受信して変数へ格納。
    - `変数, ok := <-チャネル` : close したチャネルの場合は、ok は false になる。
    - `<-チャネル` : 受信するが、受信した値は捨てる。
    - `for 変数 := range チャネル` : 受信するたびに for ループが実行される。

- select : 複数のチャネルがある場合に、先に受信した方のチャネルのデータを使うときに`select`を使う。

- コンテキスト : ネストされたゴルーチンや、派生ジョブがある複雑なロジックなどにおいても、正しく処理の**キャンセル**や終了・タイムアウトができる。context パッケージ。

<!-- TODO 章末問題ができていないので、やること！ -->

# 第 5 章 システムコール

## 5.1 システムコールとは何か？

- システムコールとは、「特権モードで OS の機能を呼ぶこと」。

  - **特権モード**とは、**ユーザーモード**よりも強い権限を持って CPU の機能を使えるモード。
  - システムコールが無いと、プロセス間通信・ファイルの入出力・共有メモリへの書き出し・外部 Web サービスなどとの通信 などができない。
    （共有メモリとか、ここに出てきた単語の意味はよく分かってない。）

## 5.3 POSIX と C 言語の標準規格

- POSIX は、システムコールのインターフェースを取り決めた規格。OS の移植性を高めるため。

<!-- TODO 章末問題ができていないので、やること！ -->

# 第 6 章 TCP ソケットと HTTP の実装

## 6.1 プロトコルとレイヤー

- TCP/IP 参照モデル
  - アプリケーション層 : HTTP
  - トランスポート層 : TCP, UDP
  - インターネット層 : IP
  - リンク（物理）層 : WiFi, イーサネット

## 6.2 HTTP とその上のプロトコルたち

HTTP は、TCP や UDP を利用して通信する、定型のフォーマット。
そのフォーマットどおりに記載されたデータを、HTTP リクエスト/レスポンスとしてやり取りする。

## 6.3 ソケットとは

- アプリケーション層（HTTP）からトランスポート層（TCP, UDP）を利用するときの API として、ソケットを利用している。

  - TLS（SSL）は HTTP とソケットの間に入って暗号化している。

- ソケットには以下の種類などがある。
  - TCP ソケット : 安定性が高い。互いに挨拶してから会話を始める。
  - UDP ソケット : 通信開始が早い。相手に一方的にデータを送りつける。
  - Unix ドメインソケット : ローカル通信でしか使えないが、最速。

## 6.4 ソケット通信の基本構造

- どんな種類のソケット通信も、下記のような形態。
  - サーバー : ソケットを開いて待ち受ける。
    - Go では、`Listen()`
  - クライアント : 開いているソケットに接続し、通信する。
    - Go では、`Dial()`

## 6.5 Go 言語で HTTP サーバーを実装する

https://github.com/ito0804takuya/go-sytem-programing/commit/0d829eec1635b5c7e1fa6f02746647c36eaf6ef6

## 6.6 速度改善（1）: HTTP/1.1 の Keep-Alive に対応させる

HTTP/1.0 では 1 セットの通信が終わるたびに TCP のコネクションを切断するが、
HTTP/1.1 では`Keep-Alive`を使うことでしばらくは TCP のコネクションを維持して使い回す。

## 6.7 速度改善（2）:圧縮

クライアントは`Accept-Encoding`で、自身が読み込める形式を指定。（gzip など）
レスポンスの`Content-Encoding`で、サーバーがどういうデータ（どう圧縮したのか）を返してきたか確認する。

## 6.8 速度改善（3）:チャンク形式のボディー送信

大きいデータを一度に返すのでなく、細切れにして少しずつ送るには、`Transfer-Encoding: chunked`とヘッダーに付ける。

# 第 7 章 UDP ソケットを使ったマルチキャスト通信

## 7.1 UDP と TCP の用途の違い

- 信頼性は低い。
- UDP はコネクションを繋がず、相手のポートにデータを送りつけるので、TCP で接続時に行う 3way ハンドシェイクを UDP では行わない。（時間がかからない。）
- マルチキャスト、ブロードキャストができる。

## 7.2 UDP と TCP の処理の流れの違い

https://github.com/ito0804takuya/go-sytem-programing/commit/1beae5b818ce98b1483abf490193f310b05d7ad6

- コネクションを繋がないのだが、Go 言語で UDP を実装する際には`net.Conn` や `net.PacketConn` 構造体を使って、TCP と同じ感覚で Conn に対して Read や Write を行う。（Go 特有）

# 第 8 章 高速な Unix ドメインソケット

## 8.1 Unix ドメインソケットの基本

- Unix ドメインソケットは、TCP 型（ストリーム型）と UDP 型（データグラム型）の両方の使い方がある。
- 通信相手を、（通常のソケット通信のように IP アドレス+ポート番号で探すのでなく）ファイルパスを使って探す。
  ただし、実体のある普通のファイルではなく、ソケットファイルという特殊なファイル。ファイルに読み書きするのではなく、あくまでプロセス間の高速な通信を実現するために、ファイルというインターフェースを利用するだけ。

# 第 9 章 ファイルシステムの基礎と Go 言語の標準パッケージ

## 9.1 ファイルシステムの基礎

- ファイルシステムはストレージ上に 1 つしかないわけでなく、Docker で使われている、chroot による擬似的なファイルシステムなども含め、複数存在する。
  これらの様々なファイルシステムは、VFS（Virtual File System）という API で、統一的に扱えるようになっている。

- ボリュームについて、論理ボリュームマネージャ（LVM）により、複数の**ストレージ（物理）**を束ねて、論理ボリュームグループを作って大きな仮想ストレージを作る。それを**ボリューム（論理）**に分割して、VFS にマウントする。

## 9.2 ファイル／ディレクトリを扱う Go 言語の関数たち

- `File.Sync()`で確実にストレージに書き込まれたことを確認できる。（Write ではメモリに書き込んだだけなので。）
  だが、重たい処理。

## 9.4 ファイルパスとマルチプラットフォーム

- `path/filepath` : OS のファイルシステムに使う
- `path` : URL に使う

## 9.5 path/filepath パッケージの関数たち

これらのパッケージを使って、簡単にファイルシステムの操作ができる。
https://pkg.go.dev/path/filepath
https://pkg.go.dev/os

# 第 10 章 ファイルシステムの最深部を扱う Go 言語の関数
## 10.1 ファイルの変更監視（syscall.Inotify\*）
ファイルの変更を監視する（例：ソースコードの変更を検知して自動コンパイル）には、2種類の方法がある。
- 監視したいファイルをOSに通知して、変更があったら教えてもらう。（OSに任せる、パッシブな方式）
- タイマーなどで定期的にフォルダを走査して、`os.Stat()`などを使って変更を探しに行く。（自ら探す、アクティブな方式）

　 10.2 ファイルのロック（syscall.Flock()）
　 10.3 ファイルのメモリへのマッピング（syscall.Mmap()）
　 10.4 同期・非同期／ブロッキング・ノンブロッキング
　 10.5 select 属のシステムコールによる I/O 多重化
　 10.6 FUSE を使った自作のファイルシステムの作成
　 10.7 本章のまとめと次章予告

第 11 章 コマンドシェル
　 11.1 シェルとは何か
　 11.2 シェルの利用形態
　 11.3 POSIX、SUS、LSB、BusyBox
　 11.4 環境変数
　 11.5 シェルがコマンドを起動するまで
　 11.6 Unix 哲学とシェル
　 11.7 まとめ

第 12 章 プロセスの役割と Go 言語による操作
　 12.1 プロセスに含まれるもの（Go 言語視点）
　 12.2 プロセスの入出力
　 12.3 自分以外のプロセスの名前や資源情報の取得
　 12.4 OS から見たプロセス
　 12.5 Go プログラムからのプロセスの起動
　 12.6 プロセスに関する便利な Go 言語のライブラリ
　 12.7 Go 言語では触れることのない世界
　 12.8 子プロセスの内部実装
　 12.9 本章のまとめと次章予告

第 13 章 シグナルによるプロセス間の通信
　 13.1 シグナルのライフサイクル
　 13.2 シグナルの種類
　 13.3 Go 言語におけるシグナルの種類
　 13.4 シグナルのハンドラを書く
　 13.5 シグナルの応用例（Server::Starter）
　 13.6 Go 言語ランタイムにおけるシグナルの内部実装
　 13.7 Windows とシグナル
　 13.8 本章のまとめと次章予告

第 14 章 Go 言語と並列処理
　 14.1 複数の仕事を同時に行うとは？
　 14.2 Go 言語の並列処理のための道具
　 14.3 スレッドと goroutine の違い
　 14.4 Go のランタイムはミニ OS
　 14.5 runtime パッケージの goroutine 関連の機能
　 14.6 RaceDetector
　 14.7 sync パッケージ
　 14.8 sync/atomic パッケージ
　 14.9 本章のまとめと次章予告

第 15 章 並行・並列処理の手法と設計のパターン
　 15.1 並行・並列処理の手法のパターン
　 15.2 Go における並行・並列処理のパターン集
　 15.3 本章のまとめと次章予告

第 16 章 Go 言語のメモリ管理
　 16.1 メモリ確保の旅
　 16.2 Go 言語の配列
　 16.3 スライスなど
　 16.4 ガベージコレクタ
　 16.5 本章のまとめと次章予告

第 17 章 実行ファイルが起動するまで
　 17.1 実行ファイルが起動するまで
　 17.2 実行ファイルを支える仕組み
　 17.3 実行ファイルのメモリ配置
　 17.4 Go のプログラムの起動
　 17.5 インタプリタでのコードの起動
　 17.6 まとめ

第 18 章 時間と時刻
　 18.1 OS のタイマー／カウンターの仕組み
　 18.2 さまざまな時間
　 18.3 時間に関するシステムコール
　 18.4 Go 言語で時間を扱う
　 18.5 時刻のフォーマット
　 18.6 本章のまとめと次章予告

第 19 章 Go 言語とコンテナ
　 19.1 仮想化
　 19.2 コンテナ
　 19.3 Windows Subsystem for Linux 2（WSL2）
　 19.4 libcontainer でコンテナを自作する
　 19.5 本章のまとめ
