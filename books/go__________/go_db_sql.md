---
title: "Go_DB、SQL"
---

# Go で DB を使うときの全体像

上から下に向かって利用する流れになる。

1. アプリケーションコードや ORM
2. 汎用 API（`database/sql`パッケージ）
   コネクションプーリングや並行処理の制御などの複雑な処理を、`database/sql`パッケージで吸収してくれている。
3. DB ドライバー
   `go-sql-driver/mysql`など。
4. DB

:::message

### ブランク import

DB ドライバーをブランク import することがある。
これで何をしているのかというと、そのドライバーパッケージの init 関数を実行させている。
その上で、DB ドライバーに直接依存させないように、`database/sql`パッケージを使うようにする といった戦略を取ることができる。
:::

# 「database/sql」パッケージ

:::message
MYSQL を使うときのチュートリアル
https://go.dev/doc/tutorial/database-access
:::

## sql.DB 構造体

sql.DB 構造体は、コネクションをプールする。
コネクション数を設定できるが、DB側の設定もするのを忘れず。
プールされていると、新規にコネクションを確立するコストがかからずに済むが、コネクションを維持するにはアプリケーションとDBの両リソースを消費するので、脳死で多くすればいい訳ではない。

また、ゴルーチンセーフなので、多数の Web アプリケーションハンドラーから同時に、かつ安全に使用できる。
（ハンドラーは「リクエストを受け取ったときに、どのようなレスポンスを返すかを決めるもの」。）

#### sql.Open を使うのは一度だけ

sql.DB 型の値がコネクションプールを持っているので、HTTP リクエストを受け取るたびに`sql.Open`関数を呼ぶとコネクションが再利用されず効率が悪い。
なので、**`sql.Open`は main 関数や初期化処理の中で、一度だけ呼ぶ**ようにする。

→ sql.DB 構造体を使い回すようにして使うこと。

## Nullable な値

`NullString` 型などがある。Valid が false なら null。

## トランザクション

#### トランザクションを使うときは、defer 文で Rollback メソッドを予約しておく

下記のように、**トランザクションを開始してすぐに、defer で Rollback メソッドを予約しておく**こと。（1 回 1 回の更新処理のたびに Rollback を書くのは、それを書き忘れる恐れがあるため。）

tx.Commit()したあとに tx.Rollback()が実行される訳だが、下記の特性があるため問題ない。

:::message
Rollback()について、下記条件下では**ロールバック処理は実行されない**。

- **Commit()した後**のロールバック。
- **キャンセル済みの context**上でのトランザクションに対するロールバック。

:::

```go
// トランザクション開始
tx, err := r.db.BeginTx(ctx, nil)
if err != nil {
  return err
}
defer tx.Rollback() // ロールバックを予約

// 更新処理1
// 更新処理2
// など...

// コミット前のこの時点で何かエラーがあるとロールバックする

return tx.Commit() // コミット → 以降、ロールバックは実行されない
```

上記のコードをまとめた関数を作っておいて、それを利用することで Rollback 忘れを防止するプラクティスもある。
