---
title: "Go_設計に関すること"
---

# オブジェクト指向プログラミング

Go はオブジェクト指向なのか という問いに対して、公式サイトでは Yes でも No でもある と回答している。
オブジェクト指向言語であるということを 下記の 3 要素を満たすこと とした場合、Go は継承に対応していないため。

- カプセル化
- 多態性（ポリモーフィズム）
- 継承
  → Go は**サブクラス**（クラスの階層構造による**継承**）に**対応していない**。

埋め込みを使うアプローチがあるが、これは継承を完全には表現できない。
**埋め込みは継承でなくコンポジションである**。

:::message

### オブジェクト指向の「関係」について

- 継承
  `サブクラス is a スーパークラス. （トラックは車。）`
- 集約
  部品として他のオブジェクトを持つが、弱い結びつき。
  関連先が消滅しても、自身は消滅しない。
  `A part of B. （駐車場Bと、そこに駐車された車A。）`
- コンポジション（合成）
  部品として他のオブジェクトを持つ、強い結びつき。
  関連先が消滅すると、自身も消滅する。
  集約と似ている概念。
  `A part of B. （エンジンAは車Bの一部。）`

#### 参考記事

https://zenn.dev/itoo/articles/object-oriented_design#%E3%82%B3%E3%83%B3%E3%83%9D%E3%82%B8%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%A8%E7%B6%99%E6%89%BF%E3%81%AE%E9%81%B8%E6%8A%9E
:::

```go:埋め込みは継承でなくコンポジション
type Dog struct {}

func (d *Dog) Bark() string { return "Bow" }

type BullDog struct { Dog }

type ShibaInu struct { Dog }

func (s *ShibaInu) Bark() string { return "ワン"}

func DogVoice(d *Dog) string { return d.Bark()}

func main() {
  bd := &BullDog{}
  fmt.Println(bd.Bark()) // Bow

  si := &ShibaInu{}
  fmt.Println(si.Bark()) // ワン

  // 下のコードはエラーが出る
  fmt.Println(DogVoice(bd))
  // → cannot use bd (variable of type *BullDog) as *Dog value in argument to DogVoice
}
```

上のコードで以下のことが分かる。

- `BullDog`は、`Dog`が持つ Bark()を実行できる。
  `ShibaInu`は更に、Bark()をオーバーライドして独自の処理を定義できている。
- しかし、`Dog`を引数にするメソッドに、`BullDogはDog`や`ShibaInu`は引数として使うことができない。
  これは、シンプルに`BullDogはDog`や`ShibaInu`は Dog 型でないから。
  つまり、`Dog`型を**継承した訳でなく**、`Dog`型の値を**保有しているだけ（= コンポジション）だから**。

よって、SOLID 原則のリスコフの原則（サブクラスは、スーパークラスを代替可能としなければならない。）は、そのまま Go に適用できない。

https://dave.cheney.net/2016/08/20/solid-go-design
https://qiita.com/shunp/items/646c86bb3cc149f7cff9



# DI（依存性の注入）

:::message

### 依存関係逆転の原則

上位のモジュールは下位のモジュールに依存してはならない。どちらも「抽象」に依存すべきである。
「抽象」は実装の詳細に依存してはならない。実装の詳細が「抽象」に依存すべきである。
:::

Go は、**実装するインターフェースを具象型が宣言しない**「**暗黙的インターフェース実装**」のみをサポートしている。
（#<利用者側で最小のインターフェースを定義する>にも記載。）

ただ、**中には、特定のインターフェースを経由して利用されることを想定した実装も存在する**。
その中の 1 つが`database/sql/driver`。

`database/sql`パッケージには、各ベンダーの個別仕様に対応する具体的な実装は含まれておらず、
各 RDMS に対応したドライバパッケージ（`github.com/go-sql-driver/mysql`など）をブランクインポートすることで、SQL ドライバが登録される。

ドライバパッケージは`database/sql/driver`インターフェースを実装している。つまり、実装の詳細（ドライバ）が、上位概念（`database/sql`）から提供されているインターフェースに依存している。
これは依存関係を逆転させた状態。

:::message
なぜこのような逆転をわざわざさせているか、私としては、クリーンアーキテクチャが参考になると考えている。
レポジトリがデータを取得する際、DB（どの RDMS を使っているか）を知っている前提で使ってしまうことを避けるためだと思う。
MySQL→PostgreSQL に変えても、レポジトリに変更は加えなくていいように、レポジトリは DB ドライバのインターフェースにだけ依存し、DB もドライバのインターフェースに依存させる。
:::

## <注入方法>

- 上位オブジェクトを初期化する際に DI する方法
- 初期化と実処理の間に DI する方法
- メソッドの引数として依存を渡す方法
  上位階層のオブジェクトのライフサイクルと、実装の詳細オブジェクトの生成が異なるときに使う。

## <過剰な抽象化に気をつける>

ソースコードの可読性を下げたり、手戻りが発生しやすくなる。


