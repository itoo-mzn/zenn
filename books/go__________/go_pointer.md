---
title: "Go_ポインタ"
---

# ポインタ

## なぜポインタを使うか

値を関数に渡すとき、**その関数内での変更は、呼び出し元に影響を与えない**。

:::message
**Go は"値渡し"の言語**。
つまり、関数に値を渡すたびに、Go がその値を受け取って**ローカルコピー(メモリ内の新しい変数)を作成**する。
:::

```go
func main() {
  first := "ジョン"
  updateName(first) // 名前を更新したはずが...
  println(first) // ジョン
}

func updateName(name string) {
  name = "田中"
}
```

updateName 関数で行う変更を main 関数の first 変数にも反映させるには、ポインタを使用する。
**ポインタで、値ではなくメモリアドレスを渡すことで、呼び出し元にも反映される**。

## ポインタとは

**変数のメモリアドレス**を示すもの。

### &演算子

変数の前に`&`を書くことで、その変数の（オブジェクトの）**アドレス**を取得する。

プリミティブ型の場合は変数に一度格納するなどしないと、ポインタが取れない。（`など`がどういう意味が調べてない。）

### \*演算子

ポインタを逆参照する。つまり、ポインタに格納されたアドレスにあるオブジェクト（ポインタが指す値）へアクセスする。

:::message

- **変数**の前に`*`を書くと、その変数が指しているアドレスに格納されている**オブジェクトの値**を取得する。これを逆参照（dereferencing）と呼ぶ。

- **型名**の前に`*`を書くと、**その型の値を格納しているポインタ**であること（=**ポインタ型**であること）を宣言する。

:::

```go
func main() {
  first := "ジョン"
  updateName(&first) // ポインタ(メモリアドレス)を渡す
  println(first) // 田中 と出力される
}

func updateName(name *string) { // stringを格納しているポインタ
  *name = "田中" // ポインタ先の文字列をupdate
}
```

:::message

### ポインタ型

ポインタ型のゼロ値は`nil`。

例えば`int`と`nil`を取りうる値の変数を定義したければ、int のポインタ型（`*int`）を使う。
ただし、`nil`のポインタ型の変数（メモリアドレスがどこも指していない）に、*演算子でアドレス先の値にアクセスしようとすると、ヌルポでエラーになる。
なので、その場合は変数が nil でないことを確認してから*演算子でアクセスする。

```go
var i *int
fmt.Println(i)  // nil
fmt.Println(*i) // i（アドレス）がnilなので、*iはアクセスがそもそもできなく、エラーになる

w := 2
i = &w
fmt.Println(i, *i) // 0x140000180a8 2

i = nil
fmt.Println(i) // nil
```

:::

:::message alert

#### スライス、マップ、チャネル はポインタを用いる必要がない（場合が多い）。

スライスの場合、`b := a`としても、スライス a が持つ**配列へのポインタ**を変数 b にコピーしているため、a と b は（背後にある）同じ配列を参照する。

ただし、（スライスでなく）**配列は、ポインタを使わないとアドレスを参照できない**。
配列の場合、`b := a`は、配列 a の持つ**値**を変数 b にコピーしている。
:::

:::message alert
ポインタが指すものが**配列の場合**、書き方に注意。

`*arr[i]` : NG（エラーになる）
`(*arr)[i]` : OK
:::
