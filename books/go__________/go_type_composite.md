---
title: "Go_複合型（コンポジット型）"
---

複数の要素を持つ型。配列、スライス、マップが該当。
（厳密にはチャネルも該当するようだが、ゴルーチンとまとめて記載したほうがいいので、ここでは記載していない。）

# 配列 : `[n]T`

特定の同じ型の、**固定長**のデータ構造。
**宣言または初期化するときにサイズ（要素数）の定義が必要**。また、**作成後にサイズを変更することができない**。
これにより、配列は Go プログラムでは一般に使用されないが、スライスとマップの基盤となっている。

## 初期化方法

#### 空の箱だけ作る（値は指定しない）場合

```go
var arr [3]int // [0 0 0]
```

↓ でもできるんだが、スライスのときは基本的には ↑ の書き方をしたほうが良いので、配列も ↑ で覚えておく。

```go:使わない
arr := [3]int{}
```

#### 値をセットして初期化する場合

```go
arr := [3]int{10, 20} // [10 20 0]
```

#### 要素数がわからない場合

```go
arr := [...]int{ ???? }
```

#### 指定の位置だけ、値をセットする方法

```go
arr := [...]int{1: 30, 4: 20} // [0 30 0 0 20]
```

## 操作

- アクセス : `arr[i]`
- 長さ : `len(arr)`
- スライス演算 : `arr[2:5]`
  配列からスライスを作る。この例だと`arr[2] から arr[5-1] まで`を抽出したものになる。（`arr[5]`まで ではないので注意!）
  ```go:スライス演算
  arr := [...]string{"a", "b", "c", "d", "e", "f"}
  fmt.Println(arr[2:5]) // [c d e]
  ```

## 2 次元配列

```go:2次元配列
var twoD [3][5]int

for i := 0; i < 3; i++ {
  for j := 0; j < 5; j++ {
    twoD[i][j] = (i + 1) * (j + 1)
  }
  fmt.Println("Row", i, ":", twoD[i])
}
fmt.Println(twoD)
/*
  Row 0 : [1 2 3 4 5]
  Row 1 : [2 4 6 8 10]
  Row 2 : [3 6 9 12 15]
  [[1 2 3 4 5] [2 4 6 8 10] [3 6 9 12 15]]
/*
```

# スライス : `[]T`

**配列の一部を切り出した**データ型。（スライスは配列を切り出したものなので、**背後には必ず配列が存在する**。）
:::message
スライスを使うときは、参照している（背後の）配列を意識すること。
:::

配列との大きな違いは、スライスの**長さ**（サイズ）が固定ではなく**動的**であること。

スライスは下記 3 つの要素を持っている。（この 3 要素の構造体である。）

1. **ポインタ** : 基となる配列の**最初の要素の場所**（**切り出した場所**）を表す。
1. **len** : 切り出した長さ。スライス内の要素数。
1. **cap**（容量） : 基になる配列に対して、ポインタの位置（切り出した位置）から配列の終端までの要素数。つまり、このスライスはどこまで拡張できるのかを表す量。

## 初期化方法

#### 空のスライス を作る場合

```go
s := []string{} // 長さ0のスライス
```

よりも

```go
var s []string // nilのスライス
```

を使う。
前者は長さ 0 のスライスを生成するが、後者は nil のスライスとなるため。
（JSON オブジェクトをエンコードする際など、限られた状況で nil ではなく長さ 0 のスライスのほうが好まれる状況がある。 nil スライスは null に変換されますが、[]string{} は [] に変換される。）

#### 指定した要素数・容量 の 空のスライス を作る場合

```go:makeメソッド
make([]int, 3, 10) // make([]型名, length, capacity)
```

#### （既にある）配列から切り出す場合

```go:スライス演算子
arr[2:5]
```

**スライス演算子**`s[i:p]`によって、この例だと`arr[2] から arr[5-1] まで`を抽出したものになる。
i と p は省略することもでき、配列の全要素をベースにする場合は`arr[:]`となる。

#### 基になる配列は指定せずにスライスだけを作る場合

```go:スライスリテラル
[]int{1, 2, 3}
```

（内部的に`{1, 2, 3}`の配列が自動で作られ、それをスライスが参照している。）

指定の位置に値を指定するには、

```go
[]int{2: 10, 5: 20} // [0 0 10 0 0 20]
```

## 基本操作

- アクセス : `sl[3]`
- 長さ : `len(sl)`
- 容量 : `cap(sl)`

## 要素の追加

```go
<スライス> = append(<スライス>, <以降、追加したい要素>)
```

- 第一引数は追加するスライスで、第二引数以降は追加したい要素。
- append の挙動によって、**配列が再確保される場合がある**ので、**append は必ず元のスライスで受けること**。

  :::details append の挙動

  - cap が足りる場合は、新しい要素を基となる配列の後ろにコピーして、len を更新すれば、要素を追加できる。
  - cap が足りない場合は、後ろに追加したくてもできないので、**元の約 2 倍の容量の配列**（を置けるメモリ）**を確保し直す**。その新しい配列を参照するようにポインタを貼り直して、元の配列から要素をコピーする。そして、新しい要素をその配列にコピーして、len と cap を更新する。
    → なので、append メソッドの左辺を別のスライスで受けると、別の配列を参照してしまっているということになりかねない。

  ```go
  // --------------------- スライスa ---------------------
  a := []int{10, 20}
  fmt.Println("A-1:", a, cap(a))

  // --------------------- スライスb ---------------------
  // aのスライスに30を追加したものを、別のbというスライスで受けると、どうなるのか？
  b := append(a, 30)
  fmt.Println("B-1:", b, cap(b)) // B-1: [10 20 30] 4
  fmt.Println("A-2:", a, cap(a)) // A-2: [10 20] 2
  // → aには追加されておらず、bにしか追加されていない。
  // つまり、スライスaとbは、別の配列をベースとして参照している。
  // これは、新しい要素30を追加するには、aのcapのままでは足りなかったため、配列を配置する容量を再確保したため。
  // bはaとは別の空間（配列）を参照するようになってしまった。

  // aに変更を加えた。bにもこの変更は伝わるのか？
  a[0] = 100
  fmt.Println("A-3:", a, cap(a)) // A-3: [100 20] 2
  fmt.Println("B-2:", b, cap(b)) // B-2: [10 20 30] 4
  // → bにaの変更が伝搬しなかった。スライスaとbは、別の配列を参照しているため、当然。

  // --------------------- スライスc ---------------------
  // aのスライスに30を追加したものを、別のbというスライスで受けた。
  // が、bには1つ容量が空いている（cap(b)が4で、実際には10, 20, 30の3つしか使っていない）ので、
  // 配列は再確保されず、bとcは同じ配列を参照する。
  c := append(b, 40)
  fmt.Println("C-1:", c, cap(c)) // C-1: [10 20 30 40] 4

  // bに変更を加えたが、bとcは同じ配列を参照しているので、当然cにもこの変更は伝わる。
  b[1] = 200
  fmt.Println("B-3:", b, cap(b)) // B-3: [10 200 30] 4
  fmt.Println("C-2:", c, cap(c)) // C-2: [10 200 30 40] 4
  ```

  :::

:::details 要素の追加に対して、スライスの容量(cap)は自動的に`2のn乗`で増える。（メモリが自動的に確保される）

```go
var numbers []int
for i := 0; i < 10; i++ {
  numbers = append(numbers, i) // 要素を追加
  fmt.Printf("%d\tcap=%d\t%v\n", i, cap(numbers), numbers)
}

/* 出力
  0       cap=1   [0]
  1       cap=2   [0 1]
  2       cap=4   [0 1 2]
  3       cap=4   [0 1 2 3]
  4       cap=8   [0 1 2 3 4]
  5       cap=8   [0 1 2 3 4 5]
  6       cap=8   [0 1 2 3 4 5 6]
  7       cap=8   [0 1 2 3 4 5 6 7]
  8       cap=16  [0 1 2 3 4 5 6 7 8]
  9       cap=16  [0 1 2 3 4 5 6 7 8 9]
/*
```

:::

## 要素の削除

下記のどちらも、（削除したい要素を除外した）**削除しない側の 2 つの要素郡をくっつける**ことで、要素を削除したスライスを作成している。

```go:i 番目の要素のみ削除
a = append(a[:i], a[i+1]...)
```

```go:i~j 番目の要素を削除
a = append(a[:i], a[j]...)
```

## 配列に影響を与えないコピーを作る : `copy()`

配列から一部の要素を切り出してスライスを作成すると、そのスライスに変更を加えると素の配列も変更される。（その逆も然り。）

そうでなく、**素の配列に影響を与えない（+影響を受けない）コピーを作る**には、
`copy(移す先のスライス, 元の配列から欲しい要素のスライス)`を使う。

```go
// 素の配列
letters := [...]string{"A", "B", "C", "D", "E"}

// 配列から切り出したスライス
slice1 := letters[0:2] // A, B

// 配列のコピーのスライス
slice2 := make([]string, 3) // cap=3と指定した 空のスライスが生成される
copy(slice2, letters[1:4]) // slice2にletters[1:4]をコピーする -> B, C, D

// 素の配列に変更を加えてみる
letters[1] = "X"

fmt.Println("slice1", slice1) // slice1 [A X] : 反映される
fmt.Println("slice2", slice2) // slice2 [B C D] : 要素が変更されていない!
```

## スライスの拡張

```go
ary := [...]int{11, 12, 13, 14}

s := ary[0:2]
fmt.Println(s, cap(s), len(s)) // [11 12] 4 2

s = s[:3]
fmt.Println(s, cap(s), len(s)) // [11 12 13] 4 3
// s = s[:3] とすることで、素の配列から切り出してくる要素が自動的に増えている！
```

## slices パッケージ

便利な関数が多くあるので、スライスを操作するときはとりあえずここを調べることから始めよう。
https://pkg.go.dev/slices

# マップ : `map[k]v{}`

**キーと値**をマッピングしたデータ型。

## 初期化方法

```go
map[string]int{ "hoge": 1, "fuga": 2 }
```

#### 空のマップを作る場合

`make()`を使う。

```go
make(map[string]int)
```

## 基本操作

- アクセス : `m["key"]`
- 存在確認 : `v, ok := m["key"]` で、v には値、ok には bool が入る。

## 項目の追加、削除

- 追加 : `m["key"] = 30`
- 削除 : `delete(m, "key")`
