---
title: "Go_ゴルーチン、チャネル"
---

# 並行と並列

## 並行処理(Concurrency)

同時にいくつかの**質の異なること**を扱うことを指す。
（一人がファイルを読み込んでいて、一人がファイルに書き込んでいる イメージ。）

## 並列処理(Parallelism)

同時にいくつかの**質の同じこと**を扱うことを指す。
（全員がファイルに書き込んでいる イメージ。）

:::message
Go で扱うのは**並行処理**(**Concurrency**)。
それを実現するのが**ゴールーチン**。
:::

https://zenn.dev/hsaki/books/golang-concurrency/viewer

# ゴールーチン と 並行処理(Concurrency)

## ゴルーチンとは

ゴールーチンは**軽量なスレッドのようなもの**。（※正確ではない）
Linux や Unix のスレッドよりもコストが低い。（→ 軽い）

:::message alert
軽量とはいえ、ゴルーチンの起動コストはゼロではない。
:::

**1 つのスレッドの上で複数のゴールーチンが動く**。

複数のゴールーチンで、同時に複数のタスク（質の異なること）を行う。

:::message
main 関数も main ゴールーチン で動いている というイメージ。
:::

## 作り方

使うには、`go`キーワードをつけて関数を呼び出すだけ。

```go:ゴールーチンの作り方
go f()
```

## 特徴

- 個々のゴルーチンは**識別できない**。
- ゴルーチンに**優先度や親子関係はない**。
- 外部から終了させることはできない。
- ゴルーチンが**終了したことを検知**するには、別の仕組みが必要。

# チャネル

チャネルは、*必ず 1 度だけ実行する*ことが保証されている**キュー**。

複数の**ゴールーチン間で値を共有**したいとき、**片方からもう片方へチャネル（経路）を通して共有する**。

チャネルはファーストクラスオブジェクト。（string とか int とか同じ）
→ 変数への代入や、引数に渡すこと、返り値にすることができる。

## <基本>

### 定義方法

- チャネルの作成 : `ch = make(chan int)`
  送受信できる値の型を定義する。
- 送信 : `ch<-100`
- 受信
  - `n := <-ch` : 受信した値を変数に格納。
  - `<-ch` : 受信した値を破棄する。
  - `n, ok := <-ch` : チャネルの状態（まだアクティブ or クローズ済み）も変数に格納。

### ブロック

チャネルが一杯のときに送信しようとしたとき や、チャネルが空のときに受信しようとしたとき にブロックする。
（→プログラムは、以降の処理に進めなくなる。）

## <select チャネル>

select チャネルによって、複数のチャネルの**先に受信したほうのデータを使う**という処理が書ける。

```go
func main() {
  ch1 := make(chan int)
  ch2 := make(chan string)
  go func() { ch1 <- 100 }()
  go func() { ch2 <- "hi" }()

  select {
  case v1 := <-ch1:
    fmt.Println("v1:", v1)
  case v2 := <-ch2:
    fmt.Println("v2:", v2)
  }
}
```

## <nil チャネル>

チャネルのゼロ値は nil。
nil のチャネルから受信しようとすると、永遠にブロックされる。

```go
func main() {
  ch1 := make(chan int)
  var ch2 chan string // ゼロ値 nil
  go func() { ch1 <- 100 }()
  go func() { ch2 <- "hi" }()

  select {
  case v1 := <-ch1:
    fmt.Println("v1:", v1)
  case v2 := <-ch2:
    // ch2がnilである間は、この処理は実行されない
    fmt.Println("v2:", v2)
  }
}
```

## <単方向チャネル>

チャネルは双方向なので、送信用として作ったつもりでも誤って受信に使ってしまったりする可能性がある。

単方向（受信 or 送信）チャネルによってそういった誤った使い方ができなくなるよう制限できる。

```go
func plusOne(recv <-chan int) int {
  // recvは受信用なので、送信には使えない
  v := <-recv + 1
  return v
}

func main() {
  ch := make(chan int)
  go func(ch chan<- int) {
    // chは送信用なので、受信には使えない
    ch <- 100
  }(ch)
  fmt.Println(plusOne(ch))
}
```

:::message

#### 解説

```go
go func(ch chan<- int) {
  // chは送信用なので、受信には使えない
  ch <- 100
}(ch)
```

このコードは、

```go
go 関数(ch)
```

を表しており、

```go
func(ch chan<- int) {
  // chは送信用なので、受信には使えない
  ch <- 100
}
```

は無名関数である。

つまり、最初に記載したコードは「無名関数を定義 + （引数に ch を渡して）即時実行」している。
:::

# コンテキスト

コンテキストとは、下記を行うためのもの。

- ゴールーチンをまたいだキャンセル処理
- ゴールーチンをまたいだ値の共有（チャネルでなくコンテキストで行いたい場合）

コンテキストは木構造みたいになっていて、必ず root が存在し、新たなコンテキストはその上にラップしている。

## <コンテキストでキャンセル>

```go
func main() {
  gen := func(ctx context.Context) <-chan int {
    dst := make(chan int)
    n := 1

    go func() {
      for {
        select {
        // 引数に受け取っているコンテキストの状態をctx.Done()で見ることによって、
        // それがキャンセルされたのかを確認
        case <-ctx.Done():
          return
        case dst <- n:
          n++
        }
      }
    }()
    return dst
  }

  // rootコンテキスト
  bc := context.Background()
  // rootコンテキストから作成した、キャンセル機能を持つコンテキスト
  ctx, cancel := context.WithCancel(bc)

  // 下のforループが終わったら、コンテキストをキャンセルして、チャネルを閉じる
  defer cancel()

  for n := range gen(ctx) { // forループには、チャネル（gen()の返り値）も取れる
    fmt.Println(n)
    if n == 5 {
      break
    }
  }
}

```
